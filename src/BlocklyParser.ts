/**
 * Elijah Cobb
 * elijah@elijahcobb.com
 * elijahcobb.com
 * github.com/elijahjcobb
 */



export const OParseBlockType = {
  TEXT: 0,    // uneditable text
  EDIT: 1,    // editable text generated by Blockly blocks
  HEAD: 2,    // initial header block
  NULL: 3,    // unused at the moment
} as const;
type ParseBlockType = typeof OParseBlockType[keyof typeof OParseBlockType];
const reverseOParseBlockType = Object.values(OParseBlockType);

export class ParseBlock {
  public type: ParseBlockType;
  public displayable: boolean;
  public editable: boolean;

  public prev: ParseBlock | null = null;
  public next: ParseBlock | null = null;

  public dispLines: string;
  public dirty: boolean = true;

  // note: position of blockly comments within a block are not guaranteed
  //   (but order is); they'll generally be moved to the beginning of the block
  public typeLine: string = "";   // a block-opener if present
  public blockLines: string[] = [];
  public textLines: string[] = [];


  public constructor(input) {
    if(typeof input === 'number') {
      if( !(input in reverseOParseBlockType)) { let msg = "Invalid block type passed to constructor"; console.error(msg); throw msg; }
      this.type = input;  // OParseBlockType
      this.typeLine = "";
    } else if(typeof input === 'string') {
      let extractType = BlocklyParse.extractShakudoComment(input);
      if(extractType === null) { let msg = "block constructor received a string that wasn't a shakudo comment"; console.error(msg); throw msg; }
      if( !(extractType in BlocklyParse.shakudo_comments_blockers)) { let msg = "block constructor received a typeLine that doesn't give a block type"; console.error(msg); throw msg; }
      this.typeLine = input;
      this.type = BlocklyParse.shakudo_comments_blockers[extractType];
    } else { let msg = "Block constructor received a wrong-typed parameter"; console.error(msg); throw msg; }

    this.displayable = [ OParseBlockType.TEXT, OParseBlockType.EDIT ].includes(this.type);
    this.editable = [ OParseBlockType.EDIT ].includes(this.type);
  }

  // check that all the block lines are valid for this block type
  // basically just tests for now,
  //     *  but later will be "evaluate the shakudo comments"   * if relevant
  public parse() {
    for(line of this.blockLines) {
      //put whatever tests you like here
      let shak_line = BlocklyParse.extractShakudoComment(line);
      console.assert(shak_line !== null, "Invalid parse: corrupted block lines");
      console.assert(shak_line in BlocklyParse.shakudo_comments, "Invalid parse: not a shakudo comment");
      console.assert(! (shak_line in BlocklyParse.shakudo_comments_blockers), "Invalid parse: block starter in block lines");
    }
  }

  // update dispLines if it's dirty
  public updateText() {
    if(this.dirty) {
      this.dispLines = this.textLines.join("\n");
      this.dirty = false;
    }
  }

}

/**
 * This class represents a particular parsing of the code.
 *  It's basically just a linked list of ParseBlocks above
 */
export class BlocklyParse {


  public firstBlock: ParseBlock;
  public outputLines: string[] = [];

  public locations: {s: number, l: number, b: ParseBlock | null }[] = [];
  public dispBlocks: ParseBlock[] = [];

  /**
   *  Generate a Parse object by calling the static parse() method
   *  @private
   */
	private constructor(firstBlock: ParseBlock) {
    this.firstBlock = firstBlock;
    // TODO: add a way so I can just iterate by, like "for blocks in _"
  }

	/**
	 * Parse the source and return an array of start and end objects determining where blocks should be.
	 * @param value The source code.
	 */
	public static parse(value: string): BlocklyParse {
    const lines: string[] = value.split("\n");

    let firstBlock = new ParseBlock(OParseBlockType.HEAD);
    let currBlock = undefined;

    // implicit 'text' block to start if there isn't an explicit first block
    let shak_line = BlocklyParse.extractShakudoComment(lines[0]);
    if( shak_line === null || !(shak_line in BlocklyParse.shakudo_comments_blockers)) {
      currBlock = new ParseBlock(OParseBlockType.TEXT);
      firstBlock.next = currBlock;
      currBlock.prev = firstBlock;
    } else {
      currBlock = firstBlock;
    }

		for (const line of lines) {
      shak_line = BlocklyParse.extractShakudoComment(line);
      if(shak_line === null) {
        currBlock.textLines.push(line);
      } else if( !(shak_line in BlocklyParse.shakudo_comments_blockers)) {
        currBlock.blockLines.push(line);
      } else {
        currBlock.parse();
        let newBlock = new ParseBlock(line);
        currBlock.next = newBlock;
        newBlock.prev = currBlock;
        currBlock = newBlock;
      }
		}
    currBlock.parse();

		let outputParse = new BlocklyParse(firstBlock);
    outputParse.updateTextLines();
    outputParse.updateLocations();
    return outputParse;
	};

  public updateTextLines() {
    this.outputLines = [];
    for(let curr: ParseBlock | null = this.firstBlock; curr !== null; curr = curr.next) {
      curr.updateText();
      if(curr.displayable) {
        this.outputLines = this.outputLines.concat(curr.dispLines);
      }
    }
  };

  public updateLocations() {
    this.locations = [ {s: 0, l: 0, b: null} ];
    for(let curr: ParseBlock | null = this.firstBlock; curr !== null; curr = curr.next) {
      curr.updateText();
      if(curr.displayable ) {
        let prevLoc = this.locations[this.locations.length - 1];
        this.locations.push(
          { s: prevLoc.s + prevLoc.l, l: curr.textLines.length, b: curr }   );
      }
    }
    this.locations.shift();
  };


  /**
   * eg "   // @shakudo-edit" --> "edit"; text lines --> null
   * should then check if the returned text is actually in blockly_comments
   */
  public static extractShakudoComment(line: string): string | null {
    line = line.trim();
    if(line.startsWith("//") || line.startsWith("--")) {
      line = line.substring(2).trim();
      if(line.startsWith("@shakudo-")) {
        line = line.substring(9).split(/\s+/, 1)[0].toLowerCase().trim();
        return line;
      }
    }
    return null;
  };

  static shakudo_comments = [ "edit", "text", "comment", "debug_hello" ];
  static shakudo_comments_blockers = {  // as in "starts a block"
    "edit": OParseBlockType.EDIT,
    "text": OParseBlockType.TEXT
  };

};






/*public parse() {
  if(this.dirty) {
    this.dispLines = [];
    for(let i = 0; i < this.rawLines.length; ++i) {
      let _line = BlocklyParse.extractShakudoComment(this.rawLines[i]);
      if(_line !== null) {
        if( ! BlocklyParse.shakudo_comments.includes(_line) ) {
          console.error(`Unrecognized Shakudo command: ${_line}`);
        } else {
          switch(_line) {
            case "edit":
            case "text":
              console.assert(i === 0,
                "Error: Somehow, a ParseBlock has a block-opening shakudo comment outside its first line.");
              console.assert(this.type === BlocklyParse.shakudo_comments_blockers[_line],
                "Error: Somehow, a ParseBlock has a block-opening shakudo comment that mismatches its type.");
              break;

            case "comment":
              // do nothing, but don't add it displayable lines
              break;

            case "debug_hello":
              console.log("Hello World!");
              this.dispLines.push("Hello World!!!");
              break;

            default:
              console.error("Error: shakudo-comment in shakudo_comments but not implemented");
          };
        }
        continue;
      }
      this.dispLines.push(this.rawLines[i]);
      this.revDispToLine.push(i);
    }
    this.dirty = false;
  }
}*/
